type: edu
custom_name: Let's throw some!
files:
- name: build.gradle
  visible: true
  text: |-
    buildscript {
        apply plugin: 'hyperskill'

        repositories {
            mavenCentral()
        }

        dependencies {
            classpath "org.springframework.boot:spring-boot-gradle-plugin:$hs.spring.bootVersion"
            classpath "io.spring.gradle:dependency-management-plugin:$hs.spring.dependencyManagementVersion"
        }
    }

    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation 'org.springframework.security:spring-security-jwt:1.1.1.RELEASE'
    }
  learner_created: false
- name: src/dartsgame/DartsGameApplication.java
  visible: true
  text: |-
    package dartsgame;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class DartsGameApplication {
        public static void main(String[] args) {
            SpringApplication.run(DartsGameApplication.class, args);
        }
    }
  learner_created: false
- name: src/resources/application.properties
  visible: true
  text: |-
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
    spring.jackson.serialization.INDENT_OUTPUT=true
  learner_created: false
- name: test/DartsGameTest.java
  visible: false
  text: |-
    import com.google.gson.JsonArray;
    import com.google.gson.JsonObject;
    import dartsgame.DartsGameApplication;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.mocks.web.request.HttpRequest;
    import org.hyperskill.hstest.mocks.web.response.HttpResponse;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.springframework.http.HttpStatus;
    import org.springframework.security.jwt.Jwt;
    import org.springframework.security.jwt.JwtHelper;
    import org.springframework.security.jwt.crypto.sign.RsaVerifier;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Map;

    import static org.hyperskill.hstest.common.JsonUtils.getJson;
    import static org.hyperskill.hstest.mocks.web.constants.Headers.AUTHORIZATION;
    import static org.hyperskill.hstest.testing.expect.Expectation.expect;
    import static org.hyperskill.hstest.testing.expect.json.JsonChecker.*;

    class TestHint {
      private final String apiPath;
      private final String requestBody;
      private final String message;

      public TestHint(String apiPath, String requestBody, String message) {
        this.apiPath = apiPath;
        this.requestBody = requestBody;
        this.message = message;
      }

      @Override
      public String toString() {
        return "Test case\n" +
                "Testing api: '" + apiPath + '\'' + "\n" +
                (requestBody.length() > 0 ? "request: '" + requestBody + '\'' + "\n" : "") +
                "Expectations: '" + message + "'" + "\n" +
                "-----";
      }
    }

    public class DartsGameTest extends SpringTest {

      private final String apiCreate = "/api/game/create";
      private final String apiList = "/api/game/list";
      private final String apiJoin = "/api/game/join";
      private final String apiStatus = "/api/game/status";
      private final String apiThrows = "/api/game/throws";
      private final String tokenApi = "/oauth/token";

      private final List<Integer> gameIds = new ArrayList();

      private String bearerToken = "";
      private final String clientId = "hyperdarts";
      private final String clientSecret = "secret";

      private final String ivanHoe = """
          {
             "name": "Ivan",
             "lastname": "Hoe",
             "email": "ivanhoe@acme.com",
             "password": "oMoa3VvqnLxW"
          }""";

      private final String robinHood = """
          {
             "name": "Robin",
             "lastname": "Hood",
             "email": "robinhood@acme.com",
             "password": "ai0y9bMvyF6G"
          }""";

      private final String wilhelmTell = """
          {
             "name": "Wilhelm",
             "lastname": "Tell",
             "email": "wilhelmtell@acme.com",
             "password": "bv0y9bMvyF7E"
          }""";

      private final String wrongUser = """
          {
             "name": "Bobin",
             "lastname": "Hood",
             "email": "bobinhood@acme.com",
             "password": "be0y9bMvyF6G"
          }""";

      private final String jwtSigningKey = """
          -----BEGIN PUBLIC KEY-----
          MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQ+7yKlJGuvYtf1soMsJjkQJGA
          Xe90QAxqppycf+3JT5ehnvvWtwS8ef+UsqrNa5Rc9tyyHjP7ZXRN145SlRTZzc0d
          03Ez10OfAEVdhGACgRxS5s+GZVtdJuVcje3Luq3VIvZ8mV/P4eRcV3yVKDwQEenM
          uL6Mh6JLH48KxgbNRQIDAQAB
          -----END PUBLIC KEY-----""";

      // for create API
      private final String wrongScore = """
          {
             "targetScore": 601
          }""";
      private final String wrongScoreAnswer = """
          {
             "result": "Wrong target score!"
          }""";
      private final String correctScore = """
          {
             "targetScore": 501
          }""";
      private final String correctScore101 = """
          {
             "targetScore": 101
          }""";
      private final String gameExistAnswer = """
          {
             "result": "You have an unfinished game!"
          }""";
      private final String answerWT = """
          {
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "",
             "gameStatus": "created",
             "playerOneScores": 101,
             "playerTwoScores": 101,
             "turn": "wilhelmtell@acme.com"
          }""";
      private final String answerRH = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "",
             "gameStatus": "created",
             "playerOneScores": 501,
             "playerTwoScores": 501,
             "turn": "ivanhoe@acme.com"
          }""";

      // for status API
      private final String emptyAnswer = "{}";
      private final String statusAnswer = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "",
             "gameStatus": "created",
             "playerOneScores": 501,
             "playerTwoScores": 501,
             "turn": "ivanhoe@acme.com"
          }""";

      private final String statusAnswer2 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "ivanhoe@acme.com wins!",
             "playerOneScores": 0,
             "playerTwoScores": 141,
             "turn": "ivanhoe@acme.com"
          }""";

      private final String statusAnswer3 = """
          {
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "started",
             "playerOneScores": 101,
             "playerTwoScores": 101,
             "turn": "wilhelmtell@acme.com"
          }""";

      private final String statusAnswer4 = """
          {
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 101,
             "playerTwoScores": 101,
             "turn": "robinhood@acme.com"
          }""";

      private final String statusAnswer5 = """
          {
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "robinhood@acme.com wins!",
             "playerOneScores": 101,
             "playerTwoScores": 0,
             "turn": "robinhood@acme.com"
          }""";

      private final String statusAnswer6 = """
          {
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "robinhood@acme.com wins!",
             "playerOneScores": 101,
             "playerTwoScores": 0,
             "turn": "robinhood@acme.com"
          }""";

      // for list API
      private final String emptyArray = "[]";
      private final String listAnswer = """
          [{
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "",
             "gameStatus": "created",
             "playerOneScores": 101,
             "playerTwoScores": 101,
             "turn": "wilhelmtell@acme.com"
          },
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "",
             "gameStatus": "created",
             "playerOneScores": 501,
             "playerTwoScores": 501,
             "turn": "ivanhoe@acme.com"
          }]"""
              ;

      private final String listAnswer2 = """
          [{
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "",
             "gameStatus": "created",
             "playerOneScores": 101,
             "playerTwoScores": 101,
             "turn": "wilhelmtell@acme.com"
          },
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "started",
             "playerOneScores": 501,
             "playerTwoScores": 501,
             "turn": "ivanhoe@acme.com"
          }]"""
              ;

      private final String listAnswer3 = """
          [{
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "",
             "gameStatus": "created",
             "playerOneScores": 101,
             "playerTwoScores": 101,
             "turn": "wilhelmtell@acme.com"
          },
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "ivanhoe@acme.com wins!",
             "playerOneScores": 0,
             "playerTwoScores": 141,
             "turn": "ivanhoe@acme.com"
          }]"""
              ;

      private final String listAnswer4 = """
          [{
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "started",
             "playerOneScores": 101,
             "playerTwoScores": 101,
             "turn": "wilhelmtell@acme.com"
          },
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "ivanhoe@acme.com wins!",
             "playerOneScores": 0,
             "playerTwoScores": 141,
             "turn": "ivanhoe@acme.com"
          }]"""
              ;

      // for join API
      private final String gameNotFound = """
          {
             "result": "Game not found!"
          }""";

      private final String unFinishedGame = """
          {
             "result": "You have an unfinished game!"
          }""";

      private final String gameInProgress = """
          {
             "result": "You can't join the game!"
          }""";

      private final String autoGame = """
          {
             "result": "You can't play alone!"
          }""";

      private final String joinAnswerIH = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "started",
             "playerOneScores": 501,
             "playerTwoScores": 501,
             "turn": "ivanhoe@acme.com"
          }""";

      private final String joinAnswerRH = """
          {
             "playerOne": "wilhelmtell@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "started",
             "playerOneScores": 101,
             "playerTwoScores": 101,
             "turn": "wilhelmtell@acme.com"
          }""";

      // throws api
      private final String correctThrows1 = """
          {
             "first": "1:1",
             "second": "2:2",
             "third": "3:3"
          }""";

      private final String correctThrows2 = """
          {
             "first": "3:20",
             "second": "3:20",
             "third": "3:20"
          }""";

      private final String correctThrows3 = """
          {
             "first": "2:25",
             "second": "3:20",
             "third": "3:20"
          }""";

      private final String correctThrows4 = """
          {
             "first": "2:25",
             "second": "2:25",
             "third": "3:9"
          }""";

      private final String correctThrows5 = """
          {
             "first": "3:17",
             "second": "3:20",
             "third": "3:10"
          }""";

      private final String correctThrows6 = """
          {
             "first": "2:10",
             "second": "none",
             "third": "none"
          }""";

      private final String wrongThrows1 = """
          {
             "first": "3:25",
             "second": "1:10",
             "third": "2:20"
          }""";

      private final String wrongThrows2 = """
          {
             "first": "2:22",
             "second": "1:10",
             "third": "2:20"
          }""";

      private final String wrongThrows3 = """
          {
             "first": "0:9",
             "second": "1:10",
             "third": "2:20"
          }""";

      private final String wrongThrows4 = """
          {
             "first": "1:26",
             "second": "1:10",
             "third": "2:20"
          }""";

      private final String wrongThrows5 = """
          {
             "first": "3:99",
             "second": "1:10",
             "third": "2:20"
          }""";

      private final String wrongBustThrows1 = """
          {
             "first": "3:20",
             "second": "3:20",
             "third": "3:20"
          }""";

      private final String CorrectBustThrows1 = """
          {
             "first": "3:20",
             "second": "3:20",
             "third": "none"
          }""";

      private final String winThrowsRH = """
          {
             "first": "3:17",
             "second": "2:25",
             "third": "none"
          }""";


      private final String wrongTurn = """
          {
             "result": "Wrong turn!"
          }""";

      private final String wrongThrowsAnswer = """
          {
             "result": "Wrong throws!"
          }""";

      private final String noGames = """
          {
             "result": "There are no games available!"
          }""";

      private final String throwsAnswer1 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 487,
             "playerTwoScores": 501,
             "turn": "robinhood@acme.com"
          }""";

      private final String throwsAnswer2 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 487,
             "playerTwoScores": 321,
             "turn": "ivanhoe@acme.com"
          }""";

      private final String throwsAnswer3 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 317,
             "playerTwoScores": 321,
             "turn": "robinhood@acme.com"
          }""";


      private final String throwsAnswer4 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 317,
             "playerTwoScores": 141,
             "turn": "ivanhoe@acme.com"
          }""";

      private final String throwsAnswer5 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 147,
             "playerTwoScores": 141,
             "turn": "robinhood@acme.com"
          }""";

      private final String throwsAnswer6 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 147,
             "playerTwoScores": 141,
             "turn": "ivanhoe@acme.com"
          }""";

      private final String throwsAnswer7 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 20,
             "playerTwoScores": 141,
             "turn": "robinhood@acme.com"
          }""";

      private final String throwsAnswer8 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "playing",
             "playerOneScores": 20,
             "playerTwoScores": 141,
             "turn": "ivanhoe@acme.com"
          }""";

      private final String throwsAnswer9 = """
          {
             "playerOne": "ivanhoe@acme.com",
             "playerTwo": "robinhood@acme.com",
             "gameStatus": "ivanhoe@acme.com wins!",
             "playerOneScores": 0,
             "playerTwoScores": 141,
             "turn": "ivanhoe@acme.com"
          }""";



      public DartsGameTest() {
        super(DartsGameApplication.class, "../service_db.mv.db");
      }

      /**
       * Method for testing api response
       *
       * @param token string representation of bearer token (String)
       * @param body request body (String)
       * @param status expected response status (int)
       * @param api testing api (String)
       * @param method method for api (String)
       * @return response (HttpResponse)
       */
      private HttpResponse checkResponseStatus(String token, String body,
                                               int status, String api, String method) {
        get(api);
        HttpRequest request = switch (method) {
          case "GET" -> get(api);
          case "POST" -> post(api, body);
          case "PUT" -> put(api, body);
          case "DELETE" -> delete(api);
          default -> get(api);
        };

        if (!token.equals("")) {
          String headerValue = "Bearer " + token;
          assert request != null;
          request = request.addHeader(AUTHORIZATION, headerValue);
        }
        HttpResponse response = request.send();

        if (response.getStatusCode() != status) {
          throw new WrongAnswer(method + " " + api  + " should respond with "
                  + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                  + "Response body:\n" + response.getContent() + "\n");
        }
        return response;
      }

      private CheckResult testApi(String api, String method,
                                  String token, String answer, TestHint hint) {

        System.out.println(hint.toString());

        HttpResponse response = checkResponseStatus(token, "", 403, api, method);

        // Check JSON in response
        if (response.getStatusCode() == 200) {
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("status", answer));

        }
        return CheckResult.correct();
      }

      private CheckResult getToken(String user, String scope, int status, TestHint hint) {

        System.out.println(hint.toString());

        JsonObject userJson = getJson(user).getAsJsonObject();
        String password = userJson.get("password").getAsString();
        String login = userJson.get("email").getAsString().toLowerCase();

        Map<String, String> urlParams = Map.of("grant_type", "password", "username", login,
                "password", password, "scope", scope);
        System.out.println("Request params:\n" +
                "Client ID: " + clientId + "\n" +
                "Client password: " + clientSecret + "\n" +
                "User: " + login + "\n" +
                "User password: " + password + "\n" +
                "Scope: " + scope);

        HttpResponse response = post("/oauth/token", urlParams)
                .basicAuth(clientId, clientSecret).send();


        if (response.getStatusCode() != status) {
          return CheckResult.wrong("POST " + tokenApi + " should respond with "
                  + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                  + response.getStatusCode() + "\n"
                  + "Response body:\n" + response.getContent() + "\n"
                  + "Request body:\n" + response.getContent());
        }
        String r = response.getContent();

        if (!r.endsWith("}")) {
          r = response.getContent() + "}";
        }
        JsonObject resp = getJson(r).getAsJsonObject();
        bearerToken = resp.get("access_token").getAsString();
        return CheckResult.correct();
      }

      private CheckResult checkToken(String user, String[] scope, TestHint hint) {

        System.out.println(hint.toString());

        JsonObject userJson = getJson(user).getAsJsonObject();
        String login = userJson.get("email").getAsString().toLowerCase();
        Jwt decodedToken;


        try {
          decodedToken = JwtHelper.decode(bearerToken);
          System.out.println("Checking token:\n" +
                  decodedToken);
        } catch (Exception e) {
          return CheckResult.wrong("Wrong token format!");
        }


        try {
          JwtHelper.decodeAndVerify(bearerToken, new RsaVerifier(jwtSigningKey));
        } catch (Exception e) {
          return CheckResult.wrong("Wrong token signature!");
        }

        expect(decodedToken.getClaims()).asJson().check(
                isObject()
                        .value("client_id", "hyperdarts")
                        .value("user_name", login)
                        .value("scope", scope)
                        .value("exp", isInteger())
                        .value("authorities", new String[] {"ROLE_GAMER"})
                        .anyOtherValues());

        return CheckResult.correct();
      }


      private CheckResult testTokenApi(String user, String clientId, String clientSecret, int status, TestHint hint) {

        System.out.println(hint.toString());

        JsonObject userJson = getJson(user).getAsJsonObject();
        String password = userJson.get("password").getAsString();
        String login = userJson.get("email").getAsString().toLowerCase();

        Map<String, String> urlParams = Map.of("grant_type", "password", "username", login, "password", password);

        HttpResponse response = post(tokenApi, urlParams)
                .basicAuth(clientId, clientSecret).send();


        if (response.getStatusCode() != status) {
          return CheckResult.wrong("POST " + tokenApi + " should respond with "
                  + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                  + response.getStatusCode() + "\n"
                  + "Response body:\n" + response.getContent() + "\n"
                  + "Request body:\n" + response.getContent());
        }
        return CheckResult.correct();
      }

      private CheckResult testCreateApi(String body, int status, String token, String answer,
                                        TestHint hint) {

        System.out.println(hint.toString());

        HttpResponse response = checkResponseStatus(token, body, status, "/api/game/create", "POST");

        JsonObject answerJson = getJson(answer).getAsJsonObject();

        if (response.getStatusCode() == 200) {
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("gameId", isInteger())
                          .value("playerOne", answerJson.get("playerOne").getAsString())
                          .value("playerTwo", answerJson.get("playerTwo").getAsString())
                          .value("gameStatus", answerJson.get("gameStatus").getAsString())
                          .value("playerOneScores", answerJson.get("playerOneScores").getAsInt())
                          .value("playerTwoScores", answerJson.get("playerTwoScores").getAsInt())
                          .value("turn", answerJson.get("turn").getAsString()));

          gameIds.add(getJson(response.getContent()).getAsJsonObject().get("gameId").getAsInt());

        } else {

          // Check JSON in response
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("result", answerJson.get("result").getAsString()));
        }

        return CheckResult.correct();
      }

      private CheckResult testStatusApi(int status, String token, String answer, TestHint hint) {

        System.out.println(hint.toString());

        HttpResponse response = checkResponseStatus(token, "", status, "/api/game/status", "GET");

        JsonObject answerJson = getJson(answer).getAsJsonObject();

        // Check JSON in response
        if (response.getStatusCode() == 200) {
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("gameId", isInteger())
                          .value("playerOne", answerJson.get("playerOne").getAsString())
                          .value("playerTwo", answerJson.get("playerTwo").getAsString())
                          .value("gameStatus", answerJson.get("gameStatus").getAsString())
                          .value("playerOneScores", answerJson.get("playerOneScores").getAsInt())
                          .value("playerTwoScores", answerJson.get("playerTwoScores").getAsInt())
                          .value("turn", answerJson.get("turn").getAsString()));

        } else {
          expect(response.getContent()).asJson().check(
                  isObject());
        }
        return CheckResult.correct();
      }

      private CheckResult testJoinApi(int status, String token, String answer, int gameId, TestHint hint) {

        System.out.println(hint.toString());

        HttpResponse response = checkResponseStatus(token, "", status, "/api/game/join" + "/" + gameId, "GET");

        JsonObject answerJson = getJson(answer).getAsJsonObject();

        // Check JSON in response
        if (response.getStatusCode() == 200) {
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("gameId", gameId)
                          .value("playerOne", answerJson.get("playerOne").getAsString())
                          .value("playerTwo", answerJson.get("playerTwo").getAsString())
                          .value("gameStatus", answerJson.get("gameStatus").getAsString())
                          .value("playerOneScores", answerJson.get("playerOneScores").getAsInt())
                          .value("playerTwoScores", answerJson.get("playerTwoScores").getAsInt())
                          .value("turn", answerJson.get("turn").getAsString()));

        } else {
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("result", answerJson.get("result").getAsString()));
        }
        return CheckResult.correct();
      }


      private CheckResult testListApi(int status, String token, String answer) {

        HttpResponse response = checkResponseStatus(token, "", status, "/api/game/list", "GET");

        JsonArray correctJson = getJson(answer).getAsJsonArray();
        JsonArray responseJson;
        try {
          responseJson = getJson(response.getContent()).getAsJsonArray();
        } catch (Exception e) {
          throw new WrongAnswer("Must be array of JSON's in answer");
        }

        // Check JSON in response
        if (response.getStatusCode() == 200) {
          for (int i = 0; i < responseJson.size(); i++) {
            expect(responseJson.get(i).getAsJsonObject().toString()).asJson()
                    .check(isObject()
                            .value("gameId", isInteger())
                            .value("playerOne", correctJson.get(i).getAsJsonObject().get("playerOne").getAsString())
                            .value("playerTwo", correctJson.get(i).getAsJsonObject().get("playerTwo").getAsString())
                            .value("gameStatus", correctJson.get(i).getAsJsonObject().get("gameStatus").getAsString())
                            .value("playerOneScores", correctJson.get(i).getAsJsonObject().get("playerOneScores").getAsInt())
                            .value("playerTwoScores", correctJson.get(i).getAsJsonObject().get("playerTwoScores").getAsInt())
                            .value("turn", correctJson.get(i).getAsJsonObject().get("turn").getAsString()));
          }
        }  else {
          expect(response.getContent()).asJson().check(
                  isArray());
        }
        return CheckResult.correct();
      }

      private CheckResult testThrowsApi(String body, int status, String token, String answer,
                                        TestHint hint) {

        System.out.println(hint.toString());

        HttpResponse response = checkResponseStatus(token, body, status, "/api/game/throws", "POST");

        JsonObject answerJson = getJson(answer).getAsJsonObject();

        if (response.getStatusCode() == 200) {
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("gameId", isInteger())
                          .value("playerOne", answerJson.get("playerOne").getAsString())
                          .value("playerTwo", answerJson.get("playerTwo").getAsString())
                          .value("gameStatus", answerJson.get("gameStatus").getAsString())
                          .value("playerOneScores", answerJson.get("playerOneScores").getAsInt())
                          .value("playerTwoScores", answerJson.get("playerTwoScores").getAsInt())
                          .value("turn", answerJson.get("turn").getAsString()));
        } else {

          // Check JSON in response
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("result", answerJson.get("result").getAsString()));
        }

        return CheckResult.correct();
      }


      @DynamicTest
      DynamicTesting[] dt = new DynamicTesting[]{
              // Negative tests
              () -> testTokenApi(ivanHoe, clientId, "clientSecret", HttpStatus.UNAUTHORIZED.value(),
                      new TestHint(tokenApi, "",
                              "Testing token endpoint with wrong client credentials")), // 1
              () -> testTokenApi(ivanHoe, "clientId", "clientSecret", HttpStatus.UNAUTHORIZED.value(),
                      new TestHint(tokenApi, "",
                              "Testing token endpoint with wrong client credentials")), // 2
              () -> testTokenApi(wrongUser, clientId, clientSecret, HttpStatus.BAD_REQUEST.value(),
                      new TestHint(tokenApi, "",
                              "Testing token endpoint with correct client credentials, but wrong user")), // 3
              () -> getToken(ivanHoe, "update", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'update'")), // 4
              () -> checkToken(ivanHoe, new String[] {"update"}, new TestHint(tokenApi, "",
                      "Checking token 'scope' value, it must be - 'update'")), // 5
              () -> testApi(apiCreate, "POST", bearerToken, "ivanhoe@acme.com",
                      new TestHint(apiCreate, "", "The token with the wrong scope (update)" +
                              " should not be able to access api")), // 6
              () -> getToken(ivanHoe, "write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'write'")), // 7
              () -> checkToken(ivanHoe, new String[] {"write"}, new TestHint(tokenApi, "",
                      "Checking token 'scope' value, it must be - 'write'")), // 8
              () -> testApi(apiList, "GET", bearerToken, "ivanhoe@acme.com",
                      new TestHint(apiList, "", "The token with the wrong scope (write)" +
                              " should not be able to access api with method GET")), // 9
              () -> getToken(ivanHoe, "read", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read'")), // 10
              () -> checkToken(ivanHoe, new String[] {"read"}, new TestHint(tokenApi, "",
                      "Checking token 'scope' value, it must be - 'read'")), // 11
              () -> testApi(apiCreate, "POST", bearerToken, "ivanhoe@acme.com",
                      new TestHint(apiCreate, "", "The token with the wrong scope (read)" +
                              " should not be able to access api with method POST")), // 12

              // Tests for status API
              () -> testStatusApi(404, bearerToken, emptyAnswer,
                      new TestHint(apiStatus, "",
                              "If the user does not participate in the game, then the endpoint must respond" +
                                      " with HTTP NOT FOUND status 404")), // 13

              // Tests for join API
              () -> testJoinApi(404, bearerToken, gameNotFound, 1001,
                      new TestHint(apiJoin + "/" + 1001, "",
                              "If a game with a specified id is not found, the endpoint must respond" +
                                      " with HTTP NOT FOUND status 404")), // 14

              // Tests for list API
              () -> testListApi(404, bearerToken, emptyArray), // 15


              // Tests for create API
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 16
              //
              () -> checkToken(ivanHoe, new String[] {"read", "write"}, new TestHint(tokenApi, "",
                      "Checking token 'scope' value, it must be - 'read write'")), // 17
              //
              () -> testCreateApi(wrongScore, 400, bearerToken, wrongScoreAnswer,
                      new TestHint(apiCreate, wrongScore,
                              "If the user specify wrong targetScore, endpoint" +
                                      " must respond with HTTP BAD REQUEST status 400")), // 18
              //
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 19
              //
              () -> checkToken(ivanHoe, new String[] {"read", "write"}, new TestHint(tokenApi, "",
                      "Checking token 'scope' value, it must be - 'read write'")), // 20
              //
              () -> testCreateApi(correctScore, 200, bearerToken, answerRH,
                      new TestHint(apiCreate, correctScore,
                              "All conditions are met and the game must be created")), // 21
              //
              () -> getToken(wilhelmTell, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 22
              //
              () -> checkToken(wilhelmTell, new String[] {"read", "write"}, new TestHint(tokenApi, "",
                      "Checking token 'scope' value, it must be - 'read write'")), // 23
              //
              () -> testCreateApi(correctScore101, 200, bearerToken, answerWT,
                      new TestHint(apiCreate, correctScore101,
                              "All conditions are met and the game must be created")), // 24
              //
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 25
              //
              () -> checkToken(ivanHoe, new String[] {"read", "write"}, new TestHint(tokenApi, "",
                      "Checking token 'scope' value, it must be - 'read write'")), // 26
              //
              () -> testCreateApi(correctScore, 400, bearerToken, gameExistAnswer,
                      new TestHint(apiCreate, correctScore,
                              "If the user tries to create a game without completing another one," +
                                      " endpoint must respond with  HTTP BAD REQUEST status 400")), // 27
              //

              // Tests for status API
              () -> testStatusApi(200, bearerToken, statusAnswer,
                      new TestHint(apiStatus, "",
                              "Endpoint must return information about a current game for player.")), // 28

              // Tests for list API
              () -> testListApi(200, bearerToken, listAnswer), // 29

              // Tests for join API
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 30
              //
              () -> testJoinApi(400, bearerToken, autoGame, gameIds.get(0),
                      new TestHint(apiJoin + "/" + gameIds.get(0), "",
                              "If a player tries to join his own game," +
                                      " the endpoint must respond with HTTP BAD REQUEST status 400")), // 31
              //
              () -> getToken(robinHood, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 32
              () -> testJoinApi(200, bearerToken, joinAnswerIH, gameIds.get(0),
                      new TestHint(apiJoin + "/" + gameIds.get(0), "",
                              "Endpoint must respond with HTTP OK status 200 and JSON about game" +
                                      " if user can join a game with specified id" +
                                      " (game status is created and the user does not participate in other games):")), // 33
              //
              () -> testJoinApi(400, bearerToken, gameInProgress, gameIds.get(0),
                      new TestHint(apiJoin + "/" + gameIds.get(0), "",
                              "If a player tries to join a game which status is not open for joining " +
                                      "(status is not created), the endpoint must respond " +
                                      "with HTTP BAD REQUEST status 400")), // 34
              //
              () -> testJoinApi(400, bearerToken, unFinishedGame, gameIds.get(1),
                      new TestHint(apiJoin + "/" + gameIds.get(1), "",
                              "If a user is involved in other game on a server," +
                                      " the endpoint must respond with HTTP BAD REQUEST status 400 ")), // 35
              //

              // Tests for list API
              () -> testListApi(200, bearerToken, listAnswer2), // 36

              // Tests for throws API
              () -> testThrowsApi(correctThrows1, 400, bearerToken, wrongTurn,
                      new TestHint(apiThrows, correctThrows1,
                              "If a player tries to make a move out of turn," +
                                      " endpoint must respond with HTTP BAD REQUEST status 400")), // 37
              //
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 38
              //
              () -> testThrowsApi(correctThrows1, 200, bearerToken, throwsAnswer1,
                      new TestHint(apiThrows, correctThrows1,
                              "If user makes correct throws scores and turn must changed," +
                                      " endpoint must respond with HTTP OK status 200")), // 39
              //
              () -> getToken(robinHood, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 40
              //
              () -> testThrowsApi(correctThrows2, 200, bearerToken, throwsAnswer2,
                      new TestHint(apiThrows, correctThrows2,
                              "If user makes correct throws scores and turn must changed," +
                                      " endpoint must respond with HTTP OK status 200")), // 41
              //
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 42
              //
              () -> testThrowsApi(correctThrows3, 200, bearerToken, throwsAnswer3,
                      new TestHint(apiThrows, correctThrows3,
                              "If user makes correct throws scores and turn must changed," +
                                      " endpoint must respond with HTTP OK status 200")), // 43
              //
              () -> getToken(robinHood, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 44
              //
              () -> testThrowsApi(correctThrows2, 200, bearerToken, throwsAnswer4,
                      new TestHint(apiThrows, correctThrows2,
                              "If user makes correct throws scores and turn must changed," +
                                      " endpoint must respond with HTTP OK status 200")), // 45
              //
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 46
              //
              () -> testThrowsApi(correctThrows3, 200, bearerToken, throwsAnswer5,
                      new TestHint(apiThrows, correctThrows3,
                              "If user makes correct throws scores and turn must changed," +
                                      " endpoint must respond with HTTP OK status 200")), // 47
              //
              () -> getToken(robinHood, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 48
              //
              () -> testThrowsApi(correctThrows2, 200, bearerToken, throwsAnswer6,
                      new TestHint(apiThrows, correctThrows2,
                              "If user BUST turn must changed, but scores not" +
                                      " endpoint must respond with HTTP OK status 200")), // 49
              //
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 50
              //
              () -> testThrowsApi(correctThrows4, 200, bearerToken, throwsAnswer7,
                      new TestHint(apiThrows, correctThrows4,
                              "If user makes correct throws scores and turn must changed," +
                                      " endpoint must respond with HTTP OK status 200")), // 51
              //
              () -> getToken(robinHood, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 52
              //
              () -> testThrowsApi(correctThrows5, 200, bearerToken, throwsAnswer8,
                      new TestHint(apiThrows, correctThrows5,
                              "If user BUST turn must changed, but scores not" +
                                      " endpoint must respond with HTTP OK status 200")), // 53
              //
              () -> getToken(ivanHoe, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 54
              //
              () -> testThrowsApi(correctThrows6, 200, bearerToken, throwsAnswer9,
                      new TestHint(apiThrows, correctThrows6,
                              "If user wins game status and user score must changes, but turn not" +
                                      " endpoint must respond with HTTP OK status 200")), // 55
              //
              () -> testThrowsApi(correctThrows6, 404, bearerToken, noGames,
                      new TestHint(apiThrows, correctThrows6,
                              "If no game is found for the user" +
                                      " endpoint must respond with HTTP NOT FOUND status 404")), // 56
              //

              // Tests for status API
              () -> testStatusApi(200, bearerToken, statusAnswer2,
                      new TestHint(apiStatus, "",
                              "Endpoint must return information about the last game played.")), // 57

              // Tests for join API
              () -> getToken(wilhelmTell, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 58
              //
              () -> testJoinApi(400, bearerToken, gameInProgress, gameIds.get(0),
                      new TestHint(apiJoin + "/" + gameIds.get(0), "",
                              "If a player tries to join a game which status is not open for joining " +
                                      "(status is not created), the endpoint must respond " +
                                      "with HTTP BAD REQUEST status 400")), // 59
              //

              // Tests for list API
              () -> testListApi(200, bearerToken, listAnswer3), // 60
              //

              // Tests for join API
              () -> getToken(robinHood, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 61
              () -> testJoinApi(200, bearerToken, joinAnswerRH, gameIds.get(1),
                      new TestHint(apiJoin + "/" + gameIds.get(0), "",
                              "Endpoint must respond with HTTP OK status 200 and JSON about game" +
                                      " if user can join a game with specified id" +
                                      " (game status is created and the user does not participate in other games):")), // 62
              //

              // Tests for list API
              () -> testListApi(200, bearerToken, listAnswer4), // 63
              //

              // Tests for throws API
              () -> getToken(wilhelmTell, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 64
              //
              () -> testThrowsApi(wrongThrows1, 400, bearerToken, wrongThrowsAnswer,
                      new TestHint(apiThrows, wrongThrows1,
                              "If a player enter a wrong throws," +
                                      " endpoint must respond with HTTP BAD REQUEST status 400")), // 65
              //
              () -> testStatusApi(200, bearerToken, statusAnswer3,
                      new TestHint(apiStatus, "",
                              "Game state after sending wrong information about throws, must not be changed")), // 66
              //
              () -> testThrowsApi(wrongThrows2, 400, bearerToken, wrongThrowsAnswer,
                      new TestHint(apiThrows, wrongThrows2,
                              "If a player enter a wrong throws," +
                                      " endpoint must respond with HTTP BAD REQUEST status 400")), // 67
              //
              () -> testThrowsApi(wrongThrows3, 400, bearerToken, wrongThrowsAnswer,
                      new TestHint(apiThrows, wrongThrows3,
                              "If a player enter a wrong throws," +
                                      " endpoint must respond with HTTP BAD REQUEST status 400")), // 68
              //
              () -> testThrowsApi(wrongThrows4, 400, bearerToken, wrongThrowsAnswer,
                      new TestHint(apiThrows, wrongThrows4,
                              "If a player enter a wrong throws," +
                                      " endpoint must respond with HTTP BAD REQUEST status 400")), // 69
              //
              () -> testThrowsApi(wrongThrows5, 400, bearerToken, wrongThrowsAnswer,
                      new TestHint(apiThrows, wrongThrows5,
                              "If a player enter a wrong throws," +
                                      " endpoint must respond with HTTP BAD REQUEST status 400")), // 70
              //
              () -> testThrowsApi(wrongBustThrows1, 400, bearerToken, wrongThrowsAnswer,
                      new TestHint(apiThrows, wrongBustThrows1,
                              "If a player enter a wrong throws (extra throws)," +
                                      " endpoint must respond with HTTP BAD REQUEST status 400")), // 71
              //
              () -> testStatusApi(200, bearerToken, statusAnswer3,
                      new TestHint(apiStatus, "",
                              "Game state after sending wrong information about throws, must not be changed")), // 72
              //
              () -> testThrowsApi(CorrectBustThrows1, 200, bearerToken, statusAnswer4,
                      new TestHint(apiThrows, CorrectBustThrows1,
                              "If user BUST turn must changed, but scores not" +
                                      " endpoint must respond with HTTP OK status 200")), // 73
              //
              () -> testStatusApi(200, bearerToken, statusAnswer4,
                      new TestHint(apiStatus, "",
                              "If user BUST turn must changed, but scores not" +
                                      " endpoint must respond with HTTP OK status 200")), // 74
              //
              () -> getToken(robinHood, "read write", HttpStatus.OK.value(), new TestHint(tokenApi, "",
                      "Testing token endpoint with correct credentials and correct user and scope 'read write'")), // 75
              //
              () -> testThrowsApi(winThrowsRH, 200, bearerToken, statusAnswer5,
                      new TestHint(apiThrows, winThrowsRH,
                              "If user wins game status and user score must changes, but turn not" +
                                      " endpoint must respond with HTTP OK status 200")), // 76

              // Tests for status API
              () -> testStatusApi(200, bearerToken, statusAnswer6,
                      new TestHint(apiStatus, "",
                              "Endpoint must return information about the last game played.")), // 77







      };
    }
  learner_created: false
- name: src/dartsgame/dto/Turn.java
  visible: true
  text: |-
    package dartsgame.dto;

    public class Turn {
        private String first = "";
        private String second = "";
        private String third = "";
        private String playerName;

        public Turn() {
        }

        @Override
        public String toString() {
            return "Turn{" +
                    ", playerName='" + playerName + '\'' +
                    "first='" + first + '\'' +
                    ", second='" + second + '\'' +
                    ", third='" + third + '\'' +
                    '}';
        }

        public Turn(String first) {
            this.first = first;
        }

        public Turn(String first, String second) {
            this.first = first;
            this.second = second;
        }

        public Turn(String first, String second, String third) {
            this.first = first;
            this.second = second;
            this.third = third;
        }

        public String getFirst() {
            return first;
        }

        public Turn setFirst(String first) {
            this.first = first;
            return this;
        }

        public String getSecond() {
            return second;
        }

        public Turn setSecond(String second) {
            this.second = second;
            return this;
        }

        public String getThird() {
            return third;
        }

        public Turn setThird(String third) {
            this.third = third;
            return this;
        }

        public String getPlayerName() {
            return playerName;
        }

        public Turn setPlayerName(String playerName) {
            this.playerName = playerName;
            return this;
        }
    }
  learner_created: true
- name: src/dartsgame/payloads/CreateDTO.java
  visible: true
  text: |+
    package dartsgame.payloads;

    public class CreateDTO {

        private int targetScore;

        public int getTargetScore() {
            return targetScore;
        }

        public CreateDTO setTargetScore(int targetScore) {
            this.targetScore = targetScore;
            return this;
        }
    }

  learner_created: true
- name: src/dartsgame/repository/GameRepository.java
  visible: true
  text: |
    package dartsgame.repository;

    import dartsgame.entity.DartsGame;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;

    import java.util.List;
    import java.util.Optional;

    @Repository
    public interface GameRepository extends JpaRepository<DartsGame, Long> {
        Optional<List<DartsGame>> findAllByPlayerOne(String playerOne);
        Optional<List<DartsGame>> findAllByPlayerTwo(String playerTwo);
        Optional<DartsGame> findByPlayerTwo(String playerTwo);
        Optional<DartsGame> findByGameId(Long id);
        Optional<DartsGame> findByPlayerOneAndGameStatus(String playerOne, String status);

        List<DartsGame> findAllByOrderByGameIdDesc();
    }
  learner_created: true
- name: src/dartsgame/cfg/SecurityConfiguration.java
  visible: true
  text: |
    package dartsgame.cfg;

    import org.springframework.context.annotation.Bean;
    import org.springframework.security.authentication.AuthenticationManager;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

    @EnableWebSecurity
    public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

        private String ivanHoe = "ivanhoe@acme.com";
        private String passwordIH = "oMoa3VvqnLxW";
        private String robinHood = "robinhood@acme.com";
        private String passwordRH = "ai0y9bMvyF6G";
        private String wilhelmTell = "wilhelmtell@acme.com";
        private String passwordWT = "bv0y9bMvyF7E";
        private final String admin = "admin@acme.com";
        private String passwordAdmin = "zy0y3bMvyA6T";

        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.inMemoryAuthentication()
                    .withUser(ivanHoe)
                    .password("{noop}" + passwordIH)
                    .roles("GAMER")
                    .and()
                    .withUser(robinHood)
                    .password("{noop}" + passwordRH)
                    .roles("GAMER")
                    .and()
                    .withUser(wilhelmTell)
                    .password("{noop}" + passwordWT)
                    .roles("GAMER")
                    .and()
                    .withUser(admin)
                    .password("{noop}" + passwordAdmin)
                    .roles("ADMIN");
        }

        @Bean
        @Override
        public AuthenticationManager authenticationManagerBean() throws Exception {
            return super.authenticationManagerBean();
        }


    }
  learner_created: true
- name: src/dartsgame/payloads/DefaultResponse.java
  visible: true
  text: |+
    package dartsgame.payloads;

    public class DefaultResponse {
        String result;

        public DefaultResponse(String result) {
            this.result = result;
        }

        public String getResult() {
            return result;
        }

        public void setResult(String result) {
            this.result = result;
        }
    }


  learner_created: true
- name: src/dartsgame/validator/DartsScoreConstraint.java
  visible: true
  text: |-
    package dartsgame.validator;

    import javax.validation.Constraint;
    import javax.validation.Payload;
    import java.lang.annotation.*;

    @Documented
    @Constraint(validatedBy = DartsScoreValidator.class)
    @Target( { ElementType.METHOD, ElementType.FIELD })
    @Retention(RetentionPolicy.RUNTIME)
    public @interface DartsScoreConstraint {
        String message() default "Invalid data";
        Class<?>[] groups() default {};
        Class<? extends Payload>[] payload() default {};
    }
  learner_created: true
- name: src/dartsgame/oauth/OAuthConfiguration.java
  visible: true
  text: |
    package dartsgame.oauth;

    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.authentication.AuthenticationManager;
    import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
    import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
    import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
    import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
    import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
    import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
    import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;

    @Configuration
    @EnableAuthorizationServer
    public class OAuthConfiguration extends AuthorizationServerConfigurerAdapter {

        private final AuthenticationManager authenticationManager;

        @Value("${jwt.clientId}")
        private String clientId;
        @Value("${jwt.client-secret}")
        private String clientSecret;
        @Value("${jwt.signing-key}")
        private String jwtSigningKey ;
        private int accessTokenValiditySeconds = 3600;
        private String[] authorizedGrantTypes = new String[] {
                "password", "authorization_code", "refresh_token"};
        private int refreshTokenValiditySeconds = 3600;

        public OAuthConfiguration(AuthenticationConfiguration authenticationConfiguration) throws Exception {
            this.authenticationManager =
                    authenticationConfiguration.getAuthenticationManager();
        }

        @Override
        public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception
        {
            oauthServer.checkTokenAccess("permitAll()");
        }

        @Override
        public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
            clients.inMemory()
                    .withClient(clientId)
                    .secret("{noop}" + clientSecret)
                    .accessTokenValiditySeconds(accessTokenValiditySeconds)
                    .refreshTokenValiditySeconds(refreshTokenValiditySeconds)
                    .authorizedGrantTypes(authorizedGrantTypes)
                    .scopes("read", "write", "update")
                    .resourceIds("api");
        }

        @Override
        public void configure(final AuthorizationServerEndpointsConfigurer endpoints) {
            endpoints
                    .accessTokenConverter(accessTokenConverter())
                    .authenticationManager(authenticationManager);
        }

        @Bean
        JwtAccessTokenConverter accessTokenConverter() {
            JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
            converter.setSigningKey(jwtSigningKey);
            return converter;
        }


    }
  learner_created: true
- name: src/dartsgame/service/GameService.java
  visible: true
  text: |
    package dartsgame.service;

    import dartsgame.entity.DartsGame;
    import dartsgame.repository.GameRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Optional;
    import java.util.stream.Collectors;
    import java.util.stream.Stream;

    @Service
    public class GameService {
        private final GameRepository gameRepository;

        List<String> openStatus = List.of("created", "started", "playing");

        @Autowired
        public GameService(GameRepository gameRepository) {
            this.gameRepository = gameRepository;
        }

        public List<DartsGame> findAll() {
            return Optional.of(gameRepository.findAllByOrderByGameIdDesc())
                    .orElse(new ArrayList<>());
        }

        public Long addGame(DartsGame dartsGame) {
            return gameRepository.save(dartsGame).getGameId();
        }

        public boolean findOpenedGames(String username) {

            List<DartsGame> games = gameRepository.findAllByPlayerOne(username).orElse(new ArrayList<>());
            if (games.isEmpty()) {
                return false;
            }
            return games.stream().anyMatch(x -> openStatus.contains(x.getGameStatus()));

    //        return gamesOptional.map(dartsGames -> dartsGames.stream()
    //                .anyMatch(x -> openStatus.contains(x.getGameStatus()))).orElse(false);
    //        return true;

        }

        public Optional<DartsGame> findCurrentGame(String username) {
            List<DartsGame> games1 = gameRepository.findAllByPlayerOne(username).orElse(new ArrayList<>());
            List<DartsGame> games2 = gameRepository.findAllByPlayerTwo(username).orElse(new ArrayList<>());
            List<DartsGame> games = Stream.concat(games1.stream(), games2.stream())
                    .collect(Collectors.toList());
            return games.stream()
                    .filter(x -> openStatus.contains(x.getGameStatus()))
                    .findFirst();
        }

        public Optional<DartsGame> findById(Long id) {
            return gameRepository.findById(id);
        }
    }
  learner_created: true
- name: src/dartsgame/payloads/JoinResponse.java
  visible: true
  text: |+
    package dartsgame.payloads;

    public class JoinResponse {
        private String status;

        public JoinResponse(String status) {
            this.status = status;
        }

        public String getStatus() {
            return status;
        }

        public JoinResponse setStatus(String status) {
            this.status = status;
            return this;
        }
    }


  learner_created: true
- name: src/dartsgame/dto/GameDTO.java
  visible: true
  text: |
    package dartsgame.dto;

    import java.util.ArrayList;
    import java.util.List;

    public class GameDTO {
        private long gameId;
        private String playerOne = "Player One";
        private String playerTwo = "Player Two";
        private String gameStatus = "Created";
        private int playerOneScores = 501;
        private int playerTwoScores = 501;
        private String turn;

        public GameDTO() {
        }

        public long getGameId() {
            return gameId;
        }

        public GameDTO setGameId(long gameId) {
            this.gameId = gameId;
            return this;
        }

        public String getPlayerOne() {
            return playerOne;
        }

        public GameDTO setPlayerOne(String playerOne) {
            this.playerOne = playerOne;
            return this;
        }

        public String getPlayerTwo() {
            return playerTwo;
        }

        public GameDTO setPlayerTwo(String playerTwo) {
            this.playerTwo = playerTwo;
            return this;
        }

        public String getGameStatus() {
            return gameStatus;
        }

        public GameDTO setGameStatus(String gameStatus) {
            this.gameStatus = gameStatus;
            return this;
        }

        public int getPlayerOneScores() {
            return playerOneScores;
        }

        public GameDTO setPlayerOneScores(int playerOneScores) {
            this.playerOneScores = playerOneScores;
            return this;
        }

        public int getPlayerTwoScores() {
            return playerTwoScores;
        }

        public GameDTO setPlayerTwoScores(int playerTwoScores) {
            this.playerTwoScores = playerTwoScores;
            return this;
        }

        public String getTurn() {
            return turn;
        }

        public GameDTO setTurn(String turn) {
            this.turn = turn;
            return this;
        }
    }
  learner_created: true
- name: src/dartsgame/validator/DartsScoreValidator.java
  visible: true
  text: |-
    package dartsgame.validator;

    import javax.validation.ConstraintValidator;
    import javax.validation.ConstraintValidatorContext;

    public class DartsScoreValidator implements
            ConstraintValidator<DartsScoreConstraint, Integer> {

        @Override
        public void initialize(DartsScoreConstraint data) {
        }

        @Override
        public boolean isValid(Integer field,
                               ConstraintValidatorContext cxt) {
            return field == 101 || field == 301 || field == 501;
        }

    }
  learner_created: true
- name: src/dartsgame/entity/DartsGame.java
  visible: true
  text: |
    package dartsgame.entity;

    import javax.persistence.*;


    @Entity
    @Table(name = "dartsGame")
    public class DartsGame {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private long gameId;
        @Column
        private String playerOne = "";
        @Column
        private String playerTwo = "";
        @Column
        private String gameStatus;
        @Column
        private int playerOneScores = 501;
        @Column
        private int playerTwoScores = 501;
        @Column
        private String turn;

        public DartsGame() {
        }

        public long getGameId() {
            return gameId;
        }

        public DartsGame setGameId(long gameId) {
            this.gameId = gameId;
            return this;
        }

        public String getPlayerOne() {
            return playerOne;
        }

        public DartsGame setPlayerOne(String playerOne) {
            this.playerOne = playerOne;
            return this;
        }

        public String getPlayerTwo() {
            return playerTwo;
        }

        public DartsGame setPlayerTwo(String playerTwo) {
            this.playerTwo = playerTwo;
            return this;
        }

        public String getGameStatus() {
            return gameStatus;
        }

        public DartsGame setGameStatus(String gameStatus) {
            this.gameStatus = gameStatus;
            return this;
        }

        public int getPlayerOneScores() {
            return playerOneScores;
        }

        public DartsGame setPlayerOneScores(int playerOneScores) {
            this.playerOneScores = playerOneScores;
            return this;
        }

        public int getPlayerTwoScores() {
            return playerTwoScores;
        }

        public DartsGame setPlayerTwoScores(int playerTwoScores) {
            this.playerTwoScores = playerTwoScores;
            return this;
        }

        public String getTurn() {
            return turn;
        }

        public DartsGame setTurn(String turn) {
            this.turn = turn;
            return this;
        }
    }
  learner_created: true
- name: src/dartsgame/controller/GameController.java
  visible: true
  text: |+
    package dartsgame.controller;


    import dartsgame.dto.GameDTO;
    import dartsgame.entity.DartsGame;
    import dartsgame.payloads.CreateDTO;
    import dartsgame.payloads.DefaultResponse;
    import dartsgame.payloads.JoinResponse;
    import dartsgame.service.GameService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpHeaders;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.access.prepost.PreAuthorize;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationDetails;
    import org.springframework.validation.annotation.Validated;
    import org.springframework.web.bind.annotation.*;

    import javax.validation.Valid;
    import java.security.Principal;
    import java.util.*;
    import java.util.stream.Collectors;

    @RestController
    @RequestMapping("/api/game")
    public class GameController {

        private Map<String, String> wrongAnswer = Map.of(
                "status", "Not under construction!"
        );

        private final GameService gameService;

        @Autowired
        public GameController(GameService gameService) {
            this.gameService = gameService;
        }


        @PostMapping("/create")
        public ResponseEntity<Object> createGame(@RequestBody @Valid CreateDTO createDTO) {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            int field = createDTO.getTargetScore();
            if (field != 101 && field != 301 && field != 501) {
                return new ResponseEntity<>(new DefaultResponse("Wrong target score!"), HttpStatus.BAD_REQUEST);
            }
            if (gameService.findOpenedGames(authentication.getName())) {
                return new ResponseEntity<>(new DefaultResponse("You have an unfinished game!"), HttpStatus.BAD_REQUEST);
            }
            DartsGame dartsGame = new DartsGame();
            dartsGame.setPlayerOne(authentication.getName());
            dartsGame.setPlayerOneScores(createDTO.getTargetScore());
            dartsGame.setPlayerTwoScores(createDTO.getTargetScore());
            dartsGame.setGameStatus("created");
            dartsGame.setTurn(authentication.getName());
            long gamedId = gameService.addGame(dartsGame);
            GameDTO gd = new GameDTO().setGameId(gamedId)
                    .setGameStatus(dartsGame.getGameStatus())
                    .setPlayerOne(dartsGame.getPlayerOne())
                    .setPlayerTwo(dartsGame.getPlayerTwo())
                    .setPlayerOneScores(dartsGame.getPlayerOneScores())
                    .setPlayerTwoScores(dartsGame.getPlayerTwoScores())
                    .setTurn(dartsGame.getPlayerOne());
            return new ResponseEntity<>(gd, HttpStatus.OK);
        }


        @GetMapping("/list")
        public ResponseEntity<Object> listGames() {
            if (gameService.findAll().isEmpty()) {
                return new ResponseEntity<>(gameService.findAll(), HttpStatus.NOT_FOUND);
            } else {
                return new ResponseEntity<>(gameService.findAll(), HttpStatus.OK);
            }
        }

        @GetMapping("/join/{gameId}")
        public ResponseEntity<Object> joinGame(@PathVariable String gameId) {
            List<String> openStatus = List.of("created", "started", "playing");
            Long id = Long.valueOf(gameId);
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            Optional<DartsGame> game = gameService.findById(id);
            if (game.isPresent()) {
                DartsGame g = game.get();
                if (g.getGameStatus().equals("created")) {
                    if (g.getPlayerOne().equals(authentication.getName())) {
                        return new ResponseEntity<>(new DefaultResponse("You can't play alone!"),
                                HttpStatus.BAD_REQUEST);
                    }
                    List<DartsGame> games = gameService.findAll();
                    if (games.stream()
                            .filter(x -> openStatus.contains(x.getGameStatus()) )
                            .anyMatch(x -> x.getPlayerTwo().equals(authentication.getName())
                                    || x.getPlayerOne().equals(authentication.getName()))) {
                        return new ResponseEntity<>(new DefaultResponse("You have an unfinished game!"),
                                HttpStatus.BAD_REQUEST);
                    }

                    g.setPlayerTwo(authentication.getName());
                    g.setGameStatus("started");
                    gameService.addGame(g);
                    GameDTO gd = new GameDTO().setGameId(g.getGameId())
                            .setGameStatus(g.getGameStatus())
                            .setPlayerOne(g.getPlayerOne())
                            .setPlayerTwo(g.getPlayerTwo())
                            .setPlayerOneScores(g.getPlayerOneScores())
                            .setPlayerTwoScores(g.getPlayerTwoScores())
                            .setTurn(g.getPlayerOne());
                    return new ResponseEntity<>(gd, HttpStatus.OK);
                } else {
                    return new ResponseEntity<>(new DefaultResponse("You can't join the game!"),
                            HttpStatus.BAD_REQUEST);
                }
            } else {
                return new ResponseEntity<>(new DefaultResponse("Game not found!"),
                        HttpStatus.NOT_FOUND);
            }
        }

        @GetMapping("/status")
        public ResponseEntity<Object> gameStatus() {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (gameService.findCurrentGame(authentication.getName()).isPresent()) {
                DartsGame dg = gameService.findCurrentGame(authentication.getName()).get();
                GameDTO gd = new GameDTO().setGameId(dg.getGameId())
                        .setGameStatus(dg.getGameStatus())
                        .setPlayerOne(dg.getPlayerOne())
                        .setPlayerTwo(dg.getPlayerTwo())
                        .setPlayerOneScores(dg.getPlayerOneScores())
                        .setPlayerTwoScores(dg.getPlayerTwoScores())
                        .setTurn(dg.getTurn());
                return new ResponseEntity<>(gd, HttpStatus.OK);
            } else {
                return new ResponseEntity<>("{}", HttpStatus.NOT_FOUND);
            }
        }

        @PostMapping("/throws")
        public ResponseEntity<Object> makeTurn() {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            Map<String, String> correctAnswer = Map.of(
                    "status", authentication.getName()
            );
            return new ResponseEntity<>(correctAnswer, HttpStatus.OK);
        }

    }

  learner_created: true
- name: src/dartsgame/oauth/ResourceServerConfiguration.java
  visible: true
  text: |+
    package dartsgame.oauth;

    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.http.HttpMethod;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.http.SessionCreationPolicy;
    import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
    import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
    import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
    import org.springframework.security.oauth2.provider.token.TokenStore;
    import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
    import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;

    @Configuration
    @EnableResourceServer
    public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {

        @Value("${jwt.verifying-key}")
        String publicKey;

        private TokenStore tokenStore;

        @Bean
        public TokenStore tokenStore() {
            if (tokenStore == null) {
                tokenStore = new JwtTokenStore(jwtAccessTokenConverter());
            }
            return tokenStore;
        }

        @Override
        public void configure(ResourceServerSecurityConfigurer resources) {
            resources.resourceId("api");
        }

        @Override
        public void configure(final HttpSecurity http) throws Exception {
            http
                    .authorizeRequests()
                    .antMatchers(HttpMethod.GET, "/**")
                    .access("(#oauth2.hasScope('read') and hasRole('ROLE_GAMER'))")
                    .antMatchers(HttpMethod.POST, "/**")
                    .access("(#oauth2.hasScope('write') and hasRole('ROLE_GAMER'))")
    //                .anyRequest().authenticated()
                    .and()
                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
                    .csrf().disable();
        }

        @Bean
        public JwtAccessTokenConverter jwtAccessTokenConverter() {
            JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
            converter.setVerifierKey(publicKey);
            return converter;
        }

    }

  learner_created: true
- name: src/dartsgame/payloads/ThrowsDTO.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/228/stages/1145/implement#comment
status: Solved
feedback:
  message: Congratulations!
  time: Wed, 12 Jan 2022 17:14:32 UTC
record: 5
